# Процесс миграции на типизированные события
* Т.к. версионирование было не предусмотренно структурой событий - для новых событий с поддержкой версионирования будем использовать новую очередь. Заодно поправим нейминг очередей.
  * accounts-cud => accounts-stream
  * tasks-cud => tasks-stream
  * tasks => tasks-workflow
* Для SchemaRegistry выделяем отдельный проект aTES.SchemaRegistry. Делаем типизированные DTO + json schema для валидации
* Общий формат сообщений `{id:string, version:string, type:string, created_at:string, producer:string, payload:{}}`
* Формат сериализации - по прежнему JSON
* Шаги миграции
  1. Добавляем новых консьюмеров, использующих новые очереди и новый формат сообщений (version = 1)
  2. Добавляем новых продьюсеров
  3. (деплой)
  4. Убираем старые продьюсеры
  5. (деплой)
  6. Проверяем, что нет не обработанных сообщений старого формата
  7. Убираем старые консьюмеры

# Замечания к ДЗ
* Для примера в рамках PR по уроку 6-7 остановимся на шаге 6 - оставим два консьюмера, но одного продьюсера
* Для экономии времени реализуем валидацию формата событий только за счет возможностей языка (типизация)
* Полноценное решение должно включать: 
  * Отдельный платформенно-независимый проект/сервис с json схемами
  * Валидацию отправляемых и принимаемых событий по схеме (для .NET: https://www.newtonsoft.com/json/help/html/JsonSchema.htm)
  * Трекинг используемых схем и прочие плюшки

## Jira-id
* Считаем, что бизнесу ок, что в старых задачах в заголовке останется Jira-id где он был добавлен руками.
* Делаем миграцию БД
  * добавляем sequence
  * обновляем старые записи, нумеруя их
* Т.к. префикс пока один (UBERPOPUG) - не храним его в БД (подставляем при чтении из БД)
* Обновляем UI - выводим ид задачи

